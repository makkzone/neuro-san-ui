# This pipeline is designed to be triggered by a github
# merge to main event or a release event.
# When that happens, the appropriate 
# values are passed to the generic 'build-all-images'
# pipeline and then the generic 'deploy' pipeline.

# The resulting behavior is: 
# - A merge to main builds all the images and deploys 
#   them to dev namespace, with short git sha as the version.
# - A release builds all the images and deploys them to
#   staging namespace, with the user-friendly semantic version tag as the version.

version: '1.0'
steps:
  clone:
    title: "Cloning repository"
    type: "git-clone"
    repo: "leaf-ai/unileaf"
    git: "github"
    revision: ${{CF_REVISION}}

  set_version_main_merge:
    title: "Set the unileaf-version for a main merge case"
    image: alpine:3.13.1
    commands:
      # This is where we map the namespace to the desired cluster.
      # Previously all namespaces were on one cluster, now we
      # have 2 clusters. By mapping the values here we can deploy any
      # arbitrary namespace on any given cluster.
      - cf_export UNILEAF_VERSION=${{CF_SHORT_REVISION}}
      - cf_export NAMESPACE=leaf-unileaf-dev
      - cf_export KUBE_CONTEXT=unileaf-dev-stage
      # Our deployment process updates a values file in the manifest
      # repo, where the directory structure uses a common-sense
      # naming pattern, eg
      # manifest/unileaf/dev/values.yaml
      # manifest/unileaf/staging/values.yaml
      # So here we map our branded-namespaces to names used in manifest repo.
      # Note: when we build the clusters again (planned soon) we
      # will use the simple namespaces of dev,staging,prod so this sort of
      # mapping can go away.
      - cf_export DEPLOY_ENV=dev

  # When codefresh sets the CF_RELEASE_TAG, this task will run
  # and switch the unileaf-version to release tag value.
  set_version_release:
    title: "Set the unileaf-version for the release case"
    image: alpine:3.13.1
    commands:
      - cf_export UNILEAF_VERSION=${{CF_RELEASE_TAG}}
      - cf_export NAMESPACE=leaf-unileaf-staging
      # The staging environment is in this cluster:
      - cf_export KUBE_CONTEXT=unileaf-dev-stage
      - cf_export DEPLOY_ENV=staging
    when:
      condition:
        all:
          # This is idiomatic Codefresh for detecting if ${{CF_RELEASE_TAG}} has a value.
          deploy_tagged_builds_only: 'includes("${{CF_RELEASE_TAG}}", "{{CF_RELEASE_TAG}}") == false'

  call_build_all_pipeline:
    title: "Run build-all-images pipeline"
    type: codefresh-run
    arguments:
      PIPELINE_ID: unileaf/build-all-images
      VARIABLE:
         # All of these values can be overridden at the build-all-images
         # pipeline by running manually.
         - UNILEAF_VERSION=${{UNILEAF_VERSION}}

  call_deploy_pipeline:
    title: "Run deploy pipeline"
    type: codefresh-run
    arguments:
      PIPELINE_ID: unileaf/deploy
      VARIABLE:
         # All of these values can be overridden at the deploy
         # pipeline by running manually.
         - UNILEAF_VERSION=${{UNILEAF_VERSION}}
         - NAMESPACE=${{NAMESPACE}}
         - KUBE_CONTEXT=${{KUBE_CONTEXT}}
         - DEPLOY_ENV=${{DEPLOY_ENV}}
